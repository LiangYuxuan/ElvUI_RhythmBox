import assert from 'node:assert';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { CASCClient, WDCReader, DBDParser } from '@rhyster/wow-casc-dbc';
import { mapSeries } from 'async';

import { region, latestVersion } from './client.ts';
import Store from './store.ts';
import updateAutoGenerated from './update.ts';

interface DataFileInfo {
    cKey: string,
    type: 'full' | 'partial',
    blocks: { offset: number, size: number }[],
}

interface BuildInfo {
    gameVersion: string,
    tasks: Map<string, number>,
    dbFiles: Map<number, DataFileInfo>,
}

interface Task {
    key: string,
    version: number,
    fileDataIDs: number[] | undefined,
    handler: (datas: DBDParser[]) => Promise<string> | string,
}

interface DataFileStatus {
    status: 'updated' | 'up-to-date',
    info: DataFileInfo,
    parser: DBDParser,
}

const store = new Store<BuildInfo>(
    path.resolve(fileURLToPath(import.meta.url), '..', '..', 'buildInfo.json'),
);

let clientCache: CASCClient | undefined;
const getClient = async () => {
    if (clientCache) {
        return clientCache;
    }

    clientCache = new CASCClient(region, latestVersion.product, latestVersion.version);
    await clientCache.init();

    console.info(new Date().toISOString(), '[INFO]: Loading remote TACT keys');
    await clientCache.loadRemoteTACTKeys();
    console.info(new Date().toISOString(), '[INFO]: Loaded remote TACT keys');

    return clientCache;
};

export const executeTasks = async (tasks: Task[], isForce: boolean) => {
    const buildInfo = await store.get();

    const forceTasks = isForce
        ? tasks
        : tasks.filter((task) => {
            const lastVersion = buildInfo?.tasks.get(task.key);
            if (lastVersion === undefined) {
                console.info(new Date().toISOString(), `[INFO]: Task ${task.key} scheduled for execution (no previous version to version ${task.version.toString()})`);
                return true;
            }
            if (lastVersion < task.version) {
                console.info(new Date().toISOString(), `[INFO]: Task ${task.key} scheduled for execution (previous version ${lastVersion.toString()} to new version ${task.version.toString()})`);
                return true;
            }
            console.info(new Date().toISOString(), `[INFO]: Task ${task.key} soft scheduled (version ${lastVersion.toString()})`);
            return false;
        });

    const softTasks = !buildInfo || buildInfo.gameVersion !== latestVersion.version.VersionsName
        ? tasks
        : forceTasks;

    if (isForce) {
        console.info(new Date().toISOString(), `[INFO]: Force run all tasks on game version ${latestVersion.version.VersionsName}`);
    } else if (!buildInfo) {
        console.info(new Date().toISOString(), `[INFO]: No build info found, run all tasks on game version ${latestVersion.version.VersionsName}`);
    } else if (buildInfo.gameVersion !== latestVersion.version.VersionsName) {
        console.info(new Date().toISOString(), `[INFO]: New game version ${latestVersion.version.VersionsName} detected`);
    } else {
        console.info(new Date().toISOString(), `[INFO]: Same game version ${latestVersion.version.VersionsName} detected`);
    }

    const cache = new Map<number, DataFileStatus>();

    await mapSeries(softTasks, async (task: Task) => {
        const { key, fileDataIDs, handler } = task;

        console.info(new Date().toISOString(), `[INFO]: Executing task ${key}`);

        if (!fileDataIDs) {
            console.info(new Date().toISOString(), `[INFO]: Task ${key} has no fileDataIDs`);

            const text = await handler([]);

            updateAutoGenerated(key, text);
        } else {
            const client = await getClient();

            const dbFiles = await Promise.all(fileDataIDs.map(async (fileDataID) => {
                const dbFile = cache.get(fileDataID);
                if (dbFile) {
                    return dbFile;
                }

                console.info(new Date().toISOString(), `[INFO]: Downloading fileDataID ${fileDataID.toString()}`);

                const cKeys = client.getContentKeysByFileDataID(fileDataID);
                assert(cKeys, `No cKeys found for fileDataID ${fileDataID.toString()}`);

                const cKey = cKeys
                    // eslint-disable-next-line no-bitwise
                    .find((data) => !!(data.localeFlags & CASCClient.LocaleFlags.enUS));
                assert(cKey, `No cKey found for fileDataID ${fileDataID.toString()} in enUS`);

                const data = await client.getFileByContentKey(cKey.cKey, true);

                let status = 'updated' as 'updated' | 'up-to-date';
                const oldBuildFile = buildInfo?.dbFiles.get(fileDataID);
                if (oldBuildFile?.cKey === cKey.cKey) {
                    if (oldBuildFile.type === 'full' && data.type === 'full') {
                        console.info(new Date().toISOString(), `[INFO]: Full file ${fileDataID.toString()} is up-to-date`);
                        status = 'up-to-date';
                    } else if (
                        oldBuildFile.type === 'partial'
                        && data.type === 'partial'
                        && oldBuildFile.blocks.length === data.blocks.length
                        && oldBuildFile.blocks.every((block, index) => (
                            block.offset === data.blocks[index].offset
                            && block.size === data.blocks[index].size
                        ))
                    ) {
                        console.info(new Date().toISOString(), `[INFO]: Partial file ${fileDataID.toString()} is up-to-date`);
                        status = 'up-to-date';
                    } else {
                        console.info(new Date().toISOString(), `[INFO]: File ${fileDataID.toString()} is decrypted more or less than before`);
                    }
                } else {
                    console.info(new Date().toISOString(), `[INFO]: File ${fileDataID.toString()} is new or changed`);
                }

                const reader = new WDCReader(data.buffer, data.blocks);

                const parser = await DBDParser.parse(reader);

                const result: DataFileStatus = {
                    status,
                    info: {
                        cKey: cKey.cKey,
                        type: data.type,
                        blocks: data.type === 'partial' ? data.blocks : [],
                    },
                    parser,
                };
                cache.set(fileDataID, result);

                return result;
            }));

            if (forceTasks.includes(task)) {
                console.info(new Date().toISOString(), `[INFO]: Task ${key} is scheduled for execution`);

                const text = await handler(dbFiles.map((dbFile) => dbFile.parser));

                updateAutoGenerated(key, text);
            } else if (dbFiles.some((dbFile) => dbFile.status === 'updated')) {
                console.info(new Date().toISOString(), `[INFO]: Task ${key} has updated files`);

                const text = await handler(dbFiles.map((dbFile) => dbFile.parser));

                updateAutoGenerated(key, text);
            } else {
                console.info(new Date().toISOString(), `[INFO]: Task ${key} has no updated files`);
            }
        }
    });

    const newBuildInfo: BuildInfo = {
        gameVersion: latestVersion.version.VersionsName,
        tasks: new Map<string, number>([
            ...(buildInfo ? [...buildInfo.tasks] : []),
            ...forceTasks.map((task) => [task.key, task.version] satisfies [string, number]),
        ]),
        dbFiles: new Map<number, DataFileInfo>([
            ...(buildInfo ? [...buildInfo.dbFiles] : []),
            ...[...cache].map(([id, { info }]) => [id, info] satisfies [number, DataFileInfo]),
        ]),
    };

    await store.set(newBuildInfo);
};

export type { Task };
