import { updateAutoGenerated } from './utils.mjs';

const armorSlots = [
    { invSlotID: 1, invType: 1, itemEquipLoc: 'Head' },
    { invSlotID: 2, invType: 2, itemEquipLoc: 'Neck' },
    { invSlotID: 3, invType: 3, itemEquipLoc: 'Shoulder' },
    { invSlotID: 5, invType: 5, itemEquipLoc: 'Chest' },
    { invSlotID: 6, invType: 6, itemEquipLoc: 'Waist' },
    { invSlotID: 7, invType: 7, itemEquipLoc: 'Legs' },
    { invSlotID: 8, invType: 8, itemEquipLoc: 'Feet' },
    { invSlotID: 9, invType: 9, itemEquipLoc: 'Wrist' },
    { invSlotID: 10, invType: 10, itemEquipLoc: 'Hands' },
    { invSlotID: 11, invType: 11, itemEquipLoc: 'Finger0' },
    { invSlotID: 12, invType: 11, itemEquipLoc: 'Finger1' },
    { invSlotID: 13, invType: 12, itemEquipLoc: 'Trinket0' },
    { invSlotID: 14, invType: 12, itemEquipLoc: 'Trinket1' },
    { invSlotID: 15, invType: 16, itemEquipLoc: 'Back' },
];

/**
 * Item limit category for Enchantment
 * @typedef {Object} itemLimitCategory
 * @property {number} id
 * @property {string} name
 * @property {number} quantity
 * @property {number} flags
 */

/**
 * Stat for Enchantment
 * @typedef {Object} Stat
 * @property {string} type
 * @property {number} amount
 */

/**
 * Equip requirements for Enchantment
 * @typedef {Object} EquipRequirements
 * @property {number} itemClass
 * @property {number} itemSubClassMask
 * @property {number} invTypeMask
 */

/**
 * Enchantment data
 * @typedef {Object} Enchantment
 * @property {number} id
 * @property {string} [baseDisplayName]
 * @property {string} displayName
 * @property {number} [spellId]
 * @property {string} [spellIcon]
 * @property {number} [itemId]
 * @property {string} [itemName]
 * @property {string} [itemIcon]
 * @property {itemLimitCategory} [itemLimitCategory]
 * @property {number} [unique]
 * @property {number} [quality]
 * @property {number} [expansion]
 * @property {number} [craftingQuality]
 * @property {string} tokenizedName
 * @property {string} [slot]
 * @property {number} [socketType]
 * @property {Stat[]} [stats]
 * @property {EquipRequirements} [equipRequirements]
 * @property {number} [categoryId]
 * @property {string} [categoryName]
 * @property {string} spellId
 */

/**
 * Enchantment data from Raidbots
 * @url https://www.raidbots.com/static/data/live/enchantments.json
 * @type {Enchantment[]}
 */
const originalData = await (await fetch('https://www.raidbots.com/static/data/live/enchantments.json')).json();

const newEnchantments = originalData.filter(({ slot, expansion }) => {
    if (slot === 'socket') {
        // not an enchantment
        return false;
    }

    if (expansion && expansion < 9) {
        // old expansion, discard
        return false;
    }

    return true;
});

/**
 * @param {Enchantment} a
 * @param {Enchantment} b
 * @returns {boolean}
 */
const isBetter = (a, b) => {
    if (a.craftingQuality && b.craftingQuality) {
        if (a.spellId && b.spellId && a.spellId === b.spellId) {
            // created by the same trade skill
            // compare crafting quality
            return a.craftingQuality > b.craftingQuality;
        }

        if (a.itemName && b.itemName && a.itemName === b.itemName) {
            // same item name, maybe same trade skill
            // compare crafting quality
            return a.craftingQuality > b.craftingQuality;
        }
    }

    if (!a.stats || !b.stats) {
        // not same trade skill
        // and no stats to compare
        return false;
    }

    const aEquip = a.equipRequirements;
    const bEquip = b.equipRequirements;

    if (aEquip.itemClass !== bEquip.itemClass) {
        // enchantments for different item classes
        return false;
    }

    if (
        aEquip.itemSubClassMask === 0
        || bEquip.itemSubClassMask === 0
        || (aEquip.itemSubClassMask | bEquip.itemSubClassMask) !== aEquip.itemSubClassMask
    ) {
        // enchantments for different item sub classes
        return false;
    }

    if (
        aEquip.invTypeMask === 0
        || bEquip.invTypeMask === 0
        || (aEquip.invTypeMask | bEquip.invTypeMask) !== aEquip.invTypeMask
    ) {
        // enchantments for different inventory types
        return false;
    }

    return b.stats.every((stat) => {
        const other = a.stats.find((oStat) => oStat.type === stat.type);
        return other && stat.amount < other.amount;
    });
}

const bestEnchantments = newEnchantments.filter((enc) => {
    const hasBetter = newEnchantments.some((other) => isBetter(other, enc));
    return !hasBetter;
});

/**
 * Extract bits from a number
 * @param {number} value
 * @returns {number[]}
 */
const extractBits = (value) => {
    const bits = [];

    let index = 0;
    while (value > 0) {
        if (value & 1) {
            bits.push(index);
        }
        index++;
        value >>= 1;
    }

    return bits;
}

const armor = armorSlots.map(({ invSlotID, invType, itemEquipLoc }) => {
    const slotEnchantments = bestEnchantments
        .filter(({ equipRequirements }) => equipRequirements?.itemClass === 4
            && (equipRequirements?.invTypeMask === 0 || (((equipRequirements?.invTypeMask ?? 0) & (1 << invType)) > 0)))
        .map(({ id, itemName, displayName, craftingQuality, equipRequirements }) => ({
            id,
            name: `${itemName ?? displayName}${craftingQuality ? ` (Tier ${craftingQuality})` : ''}`,
            itemSubClasses: equipRequirements.itemSubClassMask > 0 ? extractBits(equipRequirements.itemSubClassMask) : undefined,
        }));

    return {
        invSlotID,
        itemEquipLoc,
        enchantments: slotEnchantments.length > 0 ? slotEnchantments : undefined,
    };
});

let armorEnchantments = 'local armorEnchantments = {\n';
armorEnchantments += armor
    .map(({ invSlotID, itemEquipLoc, enchantments }) => {
        if (!enchantments) {
            return `    [${invSlotID}] = false, -- ${itemEquipLoc}`;
        } else {
            const content = enchantments
                .map((enchantment) => {
                    const subClasses = enchantment.itemSubClasses ? `{${enchantment.itemSubClasses.join(', ')}}` : 'true';
                    return `        [${enchantment.id}] = ${subClasses}, -- ${enchantment.name}`;
                })
                .join('\n');
            return `    [${invSlotID}] = { -- ${itemEquipLoc}\n${content}\n    },`;
        }
    }).join('\n');
armorEnchantments += '\n}';

const weapon = bestEnchantments
    .filter(({equipRequirements}) => equipRequirements?.itemClass === 2)
    .map(({ id, itemName, displayName, craftingQuality, equipRequirements }) => ({
        id,
        name: `${itemName ?? displayName}${craftingQuality ? ` (Tier ${craftingQuality})` : ''}`,
        itemSubClasses: equipRequirements?.itemSubClassMask > 0 ? extractBits(equipRequirements?.itemSubClassMask) : undefined,
    }));

let weaponEnchantments = 'local weaponEnchantments = {\n';
weaponEnchantments += weapon
    .map((enchantment) => {
        const subClasses = enchantment.itemSubClasses ? `{${enchantment.itemSubClasses.join(', ')}}` : 'true';
        return `    [${enchantment.id}] = ${subClasses}, -- ${enchantment.name}`;
    }).join('\n');
weaponEnchantments += '\n}';

updateAutoGenerated('InfoItemLevelEnchantments', `${armorEnchantments}\n\n${weaponEnchantments}`);
