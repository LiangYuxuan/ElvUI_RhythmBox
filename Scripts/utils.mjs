import assert from 'node:assert';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const rootDir = path.resolve(fileURLToPath(import.meta.url), '..', '..', 'Modules');

const dbcRoot = 'https://raw.githubusercontent.com/Vladinator/wow-dbc-archive';
const dbcBranch = 'release/wow_latest';

/**
 * @param {string} name
 * @returns {Promise<Record<string, string>[]>}
 */
export const fetchDBC = async (name) => {
    const url = `${dbcRoot}/${dbcBranch}/${name.toLowerCase()}.csv`;
    const res = await fetch(url);

    assert(res.ok, `Failed to fetch ${url}: ${res.status} ${res.statusText}`);

    const text = await res.text();
    const data = [];
    const headers = [];

    let isInQuote = false;
    let line = 0;
    let index = 0;
    let cell = '';
    let row = {};

    for (let i = 0; i < text.length; ++i) {
        const char = text[i];
        if (isInQuote) {
            if (char === '"' && text[i + 1] === '"') {
                cell += '"';
                ++i;
            } else if (char === '"') {
                isInQuote = false;
            } else {
                cell += char;
            }
        } else {
            if (char === '\n' || char === '\r') {
                if (char === '\r' && text[i + 1] === '\n') {
                    ++i;
                }

                if (line === 0) {
                    headers.push(cell);
                } else {
                    row[headers[index]] = cell;
                    data.push(row);
                    row = {};
                }

                ++line;
                index = 0;
                cell = '';
            } else if (char === ',') {
                if (line === 0) {
                    headers.push(cell);
                } else {
                    row[headers[index]] = cell;
                }

                ++index;
                cell = '';
            } else if (char === '"') {
                isInQuote = true;
            } else {
                cell += char;
            }
        }
    }

    return data;
};

/**
 * @param {RegExp} regex
 * @param {string} parent
 * @returns {string[]}
 */
const getFilesByRegex = (regex, parent) => {
    const results = [];

    const files = fs.readdirSync(parent);
    for (const file of files) {
        const filePath = path.join(parent, file);
        const stat = fs.statSync(filePath);
        if (stat.isDirectory()) {
            results.push(...getFilesByRegex(regex, filePath));
        } else if (stat.isFile() && path.extname(filePath) === '.lua') {
            const content = fs.readFileSync(filePath, 'utf8');
            if (content.match(regex)) {
                results.push(filePath);
            }
        }
    }

    return results;
}

/**
 * @param {string} key
 * @param {string} content
 */
export const updateAutoGenerated = (key, content) => {
    const regex = new RegExp(`([ \t]*)---AUTO_GENERATED LEADING ${key}\r?\n(.|\r|\n)*\r?\n([ \t]*)---AUTO_GENERATED TAILING ${key}\r?\n`, 'g');
    const files = getFilesByRegex(regex, rootDir);

    for (const file of files) {
        const relateivePath = path.relative(rootDir, file);
        console.log(`Handling ${relateivePath}`);

        const fileContent = fs.readFileSync(file, 'utf8');
        const newFileContent = fileContent.replace(regex, (_, indent) => {
            const newContent = `${indent}${content.replace(/\n/g, `\n${indent}`)}`;
            return `${indent}---AUTO_GENERATED LEADING ${key}\n${newContent}\n${indent}---AUTO_GENERATED TAILING ${key}\n`;
        });
        if (newFileContent !== fileContent) {
            console.log(`Updating ${relateivePath}`);
            fs.writeFileSync(file, newFileContent, 'utf8');
        }
    }
};
